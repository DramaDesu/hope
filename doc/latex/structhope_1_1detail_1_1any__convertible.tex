\hypertarget{structhope_1_1detail_1_1any__convertible}{
\section{hope::detail::any\_\-convertible$<$ TStruct, I $>$ Struct Template Reference}
\label{structhope_1_1detail_1_1any__convertible}\index{hope::detail::any\_\-convertible@{hope::detail::any\_\-convertible}}
}
{\tt \#include $<$detect\_\-fields\_\-count.h$>$}

\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
\hypertarget{structhope_1_1detail_1_1any__convertible_54b3deb82f30f927d87ed6184bd54f59}{
{\footnotesize template$<$typename T , typename  = std::enable\_\-if\_\-t$<$!std::is\_\-base\_\-of\_\-v$<$T, TStruct$>$$>$$>$ }\\constexpr \textbf{operator T \&} () const noexcept}
\label{structhope_1_1detail_1_1any__convertible_54b3deb82f30f927d87ed6184bd54f59}

\end{CompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename TStruct, std::size\_\-t I$>$ struct hope::detail::any\_\-convertible$<$ TStruct, I $>$}

The only one reason of existing of this class is initialization of object of different types. This is the same as ubiq from magic-get \begin{Desc}
\item[Template Parameters:]
\begin{description}
\item[{\em TStruct}]Type to be converted to \item[{\em I}]Index, is used to unambiguously define the type \end{description}
\end{Desc}


The documentation for this struct was generated from the following file:\begin{CompactItemize}
\item 
lib/hope/tuple/\hyperlink{detect__fields__count_8h}{detect\_\-fields\_\-count.h}\end{CompactItemize}
