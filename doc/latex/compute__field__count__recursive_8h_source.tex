\hypertarget{compute__field__count__recursive_8h_source}{}\doxysection{compute\+\_\+field\+\_\+count\+\_\+recursive.\+h}
\label{compute__field__count__recursive_8h_source}\index{lib/hope/tuple/compute\_field\_count\_recursive.h@{lib/hope/tuple/compute\_field\_count\_recursive.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/* Copyright (C) 2020 -\/ 2021 Gleb Bezborodov -\/ All Rights Reserved}}
\DoxyCodeLine{2 \textcolor{comment}{ * You may use, distribute and modify this code under the}}
\DoxyCodeLine{3 \textcolor{comment}{ * terms of the MIT license.}}
\DoxyCodeLine{4 \textcolor{comment}{ *}}
\DoxyCodeLine{5 \textcolor{comment}{ * You should have received a copy of the MIT license with}}
\DoxyCodeLine{6 \textcolor{comment}{ * this file. If not, please write to: bezborodoff.gleb@gmail.com, or visit : https://github.com/glensand/hope}}
\DoxyCodeLine{7 \textcolor{comment}{ */}}
\DoxyCodeLine{8 }
\DoxyCodeLine{9 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include "{}hope/tuple/tuple\_from\_struct.h"{}}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include "{}hope/tuple/tuple\_from\_struct\_unsafe.h"{}}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include "{}hope/tuple/tuple\_policy.h"{}}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include "{}hope/components/user\_defined\_types.h"{}}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include "{}hope/components/detector.h"{}}}
\DoxyCodeLine{16 }
\DoxyCodeLine{17 \textcolor{keyword}{namespace }hope \{}
\DoxyCodeLine{18 }
\DoxyCodeLine{19     \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{20 }
\DoxyCodeLine{21         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{22         \textcolor{keyword}{constexpr} std::enable\_if\_t<!is\_user\_defined\_type\_v<T>, std::size\_t>}
\DoxyCodeLine{23         compute\_via\_type\_list() \{}
\DoxyCodeLine{24             \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{25         \}}
\DoxyCodeLine{26 }
\DoxyCodeLine{27         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{28         \textcolor{keyword}{constexpr} std::enable\_if\_t<is\_user\_defined\_type\_v<T>, std::size\_t>}
\DoxyCodeLine{29         compute\_via\_type\_list() \{}
\DoxyCodeLine{30             \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} fields\_count = detect\_fields\_count<T>();}
\DoxyCodeLine{31             \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} types = detail::extract\_types<T>(std::make\_index\_sequence<fields\_count>());}
\DoxyCodeLine{32             std::size\_t count\{ 0 \};}
\DoxyCodeLine{33             for\_each(types, [\&] (\textcolor{keyword}{auto} field) \{}
\DoxyCodeLine{34                 \textcolor{keyword}{using} type\_t = \textcolor{keyword}{typename} \textcolor{keyword}{decltype}(field)::Type;}
\DoxyCodeLine{35                 count += compute\_via\_type\_list<type\_t>();}
\DoxyCodeLine{36             \});}
\DoxyCodeLine{37             }
\DoxyCodeLine{38             \textcolor{keywordflow}{return} count;}
\DoxyCodeLine{39         \}}
\DoxyCodeLine{40 }
\DoxyCodeLine{41         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{42         std::enable\_if\_t<!is\_user\_defined\_type\_v<T>, std::size\_t>}
\DoxyCodeLine{43         compute\_via\_tuple() \{}
\DoxyCodeLine{44             \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{45         \}}
\DoxyCodeLine{46 }
\DoxyCodeLine{47         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{48         std::enable\_if\_t<is\_user\_defined\_type\_v<T>, std::size\_t>}
\DoxyCodeLine{49         compute\_via\_tuple() \{}
\DoxyCodeLine{50             \textcolor{keyword}{const} T \textcolor{keywordtype}{object}\{ \};}
\DoxyCodeLine{51             \textcolor{keyword}{auto} tuple = tuple\_from\_struct(\textcolor{keywordtype}{object}, field\_policy::reference\{ \});}
\DoxyCodeLine{52             std::size\_t count\{ 0 \};}
\DoxyCodeLine{53             for\_each(tuple, [\&](\textcolor{keyword}{auto} \&\&field) \{}
\DoxyCodeLine{54                 \textcolor{keyword}{using} type\_t = std::decay\_t<\textcolor{keyword}{decltype}(field)>;}
\DoxyCodeLine{55                 count += compute\_via\_tuple<type\_t>();}
\DoxyCodeLine{56             \});}
\DoxyCodeLine{57             \textcolor{keywordflow}{return} count;}
\DoxyCodeLine{58         \}}
\DoxyCodeLine{59 }
\DoxyCodeLine{60     \}}
\DoxyCodeLine{61 }
\DoxyCodeLine{62     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{63     \textcolor{keyword}{constexpr} std::size\_t compute\_field\_count\_recursive\_constexpr() \{}
\DoxyCodeLine{64         \textcolor{keywordflow}{return} detail::compute\_via\_type\_list<T>();}
\DoxyCodeLine{65     \}}
\DoxyCodeLine{66 }
\DoxyCodeLine{67     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{68     \textcolor{keyword}{constexpr} std::size\_t compute\_field\_count\_recursive() \{}
\DoxyCodeLine{69             \textcolor{keywordflow}{return} detail::compute\_via\_tuple<T>();}
\DoxyCodeLine{70     \}}
\DoxyCodeLine{71 }
\DoxyCodeLine{72 \}}

\end{DoxyCode}
