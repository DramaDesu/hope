\hypertarget{flat__tuple_8h_source}{}\doxysection{flat\+\_\+tuple.\+h}
\label{flat__tuple_8h_source}\index{lib/hope/tuple/flat\_tuple.h@{lib/hope/tuple/flat\_tuple.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/* Copyright (C) 2020 -\/ 2021 Gleb Bezborodov -\/ All Rights Reserved}}
\DoxyCodeLine{2 \textcolor{comment}{ * You may use, distribute and modify this code under the}}
\DoxyCodeLine{3 \textcolor{comment}{ * terms of the MIT license.}}
\DoxyCodeLine{4 \textcolor{comment}{ *}}
\DoxyCodeLine{5 \textcolor{comment}{ * You should have received a copy of the MIT license with}}
\DoxyCodeLine{6 \textcolor{comment}{ * this file. If not, please write to: bezborodoff.gleb@gmail.com, or visit : https://github.com/glensand/hope}}
\DoxyCodeLine{7 \textcolor{comment}{ */}}
\DoxyCodeLine{8 }
\DoxyCodeLine{9 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include "{}hope/typelist/type\_list.h"{}}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{keyword}{namespace }hope \{}
\DoxyCodeLine{14     \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{15 }
\DoxyCodeLine{19         \textcolor{keyword}{struct }\mbox{\hyperlink{structhope_1_1detail_1_1tuple__tag}{tuple\_tag}} \{ \};}
\DoxyCodeLine{20 }
\DoxyCodeLine{21         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} I>}
\DoxyCodeLine{22         \textcolor{keyword}{struct }\mbox{\hyperlink{structhope_1_1detail_1_1indexed__value}{indexed\_value}} \{}
\DoxyCodeLine{23             \textcolor{keyword}{constexpr} \mbox{\hyperlink{structhope_1_1detail_1_1indexed__value}{indexed\_value}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{24             \textcolor{keyword}{constexpr} \mbox{\hyperlink{structhope_1_1detail_1_1indexed__value}{indexed\_value}}(\mbox{\hyperlink{structhope_1_1detail_1_1indexed__value}{indexed\_value}}\&\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{25             \textcolor{keyword}{constexpr} \mbox{\hyperlink{structhope_1_1detail_1_1indexed__value}{indexed\_value}}(\textcolor{keyword}{const} \mbox{\hyperlink{structhope_1_1detail_1_1indexed__value}{indexed\_value}}\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{26 }
\DoxyCodeLine{27             \mbox{\hyperlink{structhope_1_1detail_1_1indexed__value}{\string~indexed\_value}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{28 }
\DoxyCodeLine{29             \textcolor{keyword}{template}<\textcolor{keyword}{typename} Vt,}
\DoxyCodeLine{30                 \textcolor{keyword}{typename} = std::is\_constructible<T, Vt>>}
\DoxyCodeLine{31                 \textcolor{keyword}{explicit} \textcolor{keyword}{constexpr} \mbox{\hyperlink{structhope_1_1detail_1_1indexed__value}{indexed\_value}}(Vt\&\& valueRef)}
\DoxyCodeLine{32                 : value(std::forward<Vt>(valueRef)) \{ \}}
\DoxyCodeLine{33 }
\DoxyCodeLine{34             T value;}
\DoxyCodeLine{35         \};}
\DoxyCodeLine{36 }
\DoxyCodeLine{37         \textcolor{keyword}{template} <\textcolor{keyword}{typename}, \textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{38         \textcolor{keyword}{class }\mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl}{flat\_tuple\_impl}};}
\DoxyCodeLine{39 }
\DoxyCodeLine{40         \textcolor{keyword}{template}<std::size\_t... Is, \textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{41         \textcolor{keyword}{class }\mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl}{flat\_tuple\_impl}}<std::index\_sequence<Is...>, Ts...> : \textcolor{keyword}{public} \mbox{\hyperlink{structhope_1_1detail_1_1tuple__tag}{tuple\_tag}}, \textcolor{keyword}{public} \mbox{\hyperlink{structhope_1_1detail_1_1indexed__value}{indexed\_value}} <Ts, Is>... \{}
\DoxyCodeLine{42             \textcolor{keyword}{using} \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_01_4_00_01_ts_8_8_8_01_4}{self\_t}} = \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl}{flat\_tuple\_impl}}<std::index\_sequence<Is...>, Ts...>;}
\DoxyCodeLine{43             \textcolor{keyword}{constexpr} \textcolor{keyword}{static} \mbox{\hyperlink{classhope_1_1type__list}{type\_list<std::decay\_t<Ts>}}...> types\{ \}; \textcolor{comment}{// only clear types might be used, thus make it clear here}}
\DoxyCodeLine{44 }
\DoxyCodeLine{45             \textcolor{keyword}{template} <std::\textcolor{keywordtype}{size\_t} I>}
\DoxyCodeLine{46             \textcolor{keyword}{using} native\_t = std::decay\_t<typename decltype(get\_nth\_type<I>(types))::Type>;}
\DoxyCodeLine{47         \textcolor{keyword}{protected}:}
\DoxyCodeLine{48             \textcolor{keyword}{using} \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_01_4_00_01_ts_8_8_8_01_4}{flat\_tuple}} = \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl}{flat\_tuple\_impl}}<std::index\_sequence<Is...>, Ts...>;}
\DoxyCodeLine{49             \textcolor{keyword}{constexpr} \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl}{flat\_tuple\_impl}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{50             \textcolor{keyword}{constexpr} \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl}{flat\_tuple\_impl}}(\textcolor{keyword}{const} \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl}{flat\_tuple\_impl}}\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{51             \textcolor{keyword}{constexpr} \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl}{flat\_tuple\_impl}}(\mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl}{flat\_tuple\_impl}}\&\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{52 }
\DoxyCodeLine{53             \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl}{\string~flat\_tuple\_impl}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{54 }
\DoxyCodeLine{55             \textcolor{keyword}{template} <\textcolor{keyword}{typename}... VTs>}
\DoxyCodeLine{56             \textcolor{keyword}{constexpr} \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl}{flat\_tuple\_impl}}(VTs\&\&... elems) noexcept}
\DoxyCodeLine{57                 : \mbox{\hyperlink{structhope_1_1detail_1_1indexed__value}{indexed\_value<Ts, Is>}}(std::forward<VTs>(elems))...}
\DoxyCodeLine{58             \{ \}}
\DoxyCodeLine{59         \textcolor{keyword}{public}:}
\DoxyCodeLine{60             \textcolor{keyword}{constexpr} \textcolor{keyword}{static} std::size\_t tuple\_size\{ size(types) \};}
\DoxyCodeLine{61 }
\DoxyCodeLine{73             \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} NativeT = std::decay\_t<T>>}
\DoxyCodeLine{74             [[nodiscard]] \textcolor{keyword}{constexpr} \textcolor{keyword}{decltype}(\textcolor{keyword}{auto})}
\DoxyCodeLine{75             \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_01_4_00_01_ts_8_8_8_01_4_a614a63b798ed5f427da6aa7bf08111a2}{get}}() \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{76                 \textcolor{keyword}{static\_assert}(contains<NativeT>(types));}
\DoxyCodeLine{77                 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} TypeIndex = find<NativeT>(types);}
\DoxyCodeLine{78                 \textcolor{keyword}{using} value\_t = \textcolor{keyword}{typename} \textcolor{keyword}{decltype}(deduce\_type<NativeT, TypeIndex>())::Type;}
\DoxyCodeLine{79                 \textcolor{keywordflow}{return} get\_impl<TypeIndex, value\_t>();}
\DoxyCodeLine{80             \}}
\DoxyCodeLine{81 }
\DoxyCodeLine{93             \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} NativeT = std::decay\_t<T>>}
\DoxyCodeLine{94             [[nodiscard]] \textcolor{keyword}{constexpr} \textcolor{keyword}{decltype}(\textcolor{keyword}{auto})}
\DoxyCodeLine{95             \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_01_4_00_01_ts_8_8_8_01_4_ab64701e05abfc78fb43f703577cb9920}{get}}() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{96                 \textcolor{keyword}{static\_assert}(contains<NativeT>(types));}
\DoxyCodeLine{97                 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} TypeIndex = find<NativeT>(types);}
\DoxyCodeLine{98                 \textcolor{keyword}{using} value\_t = \textcolor{keyword}{typename} \textcolor{keyword}{decltype}(deduce\_type<NativeT, TypeIndex>())::Type;}
\DoxyCodeLine{99                 \textcolor{keywordflow}{return} get\_impl<TypeIndex, value\_t>();}
\DoxyCodeLine{100             \}}
\DoxyCodeLine{101 }
\DoxyCodeLine{108             \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{109             [[nodiscard]] \textcolor{keyword}{constexpr} \textcolor{keyword}{decltype}(\textcolor{keyword}{auto})}
\DoxyCodeLine{110             \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_01_4_00_01_ts_8_8_8_01_4_a72594a3474312e81860ed0dc8c72b29e}{get}}() \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{111                 \textcolor{keyword}{static\_assert}(tuple\_size > N);}
\DoxyCodeLine{112                 \textcolor{keyword}{using} value\_t = \textcolor{keyword}{typename} \textcolor{keyword}{decltype}(deduce\_type<native\_t<N>, N>())::Type;}
\DoxyCodeLine{113                 \textcolor{keywordflow}{return} get\_impl<N, value\_t>();}
\DoxyCodeLine{114             \}}
\DoxyCodeLine{115 }
\DoxyCodeLine{122             \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{123             [[nodiscard]] \textcolor{keyword}{constexpr} \textcolor{keyword}{decltype}(\textcolor{keyword}{auto})}
\DoxyCodeLine{124             \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_01_4_00_01_ts_8_8_8_01_4_a96a39d2d700295e27342636e64a3dc47}{get}}() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{125                 \textcolor{keyword}{static\_assert}(tuple\_size > N);}
\DoxyCodeLine{126                 \textcolor{keyword}{using} value\_t = \textcolor{keyword}{typename} \textcolor{keyword}{decltype}(deduce\_type<native\_t<N>, N>())::Type;}
\DoxyCodeLine{127                 \textcolor{keywordflow}{return} get\_impl<N, value\_t>();}
\DoxyCodeLine{128             \}}
\DoxyCodeLine{129 }
\DoxyCodeLine{135             \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{136             \textcolor{keyword}{constexpr} \textcolor{keywordtype}{void} \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_01_4_00_01_ts_8_8_8_01_4_ac08ef238632966d87e990d0b5de6e372}{for\_each}}(F\&\& f)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{137                 (f(\mbox{\hyperlink{structhope_1_1detail_1_1get}{get<Is>}}()), ...);}
\DoxyCodeLine{138             \}}
\DoxyCodeLine{139 }
\DoxyCodeLine{140             \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{141             \textcolor{keyword}{constexpr} \textcolor{keywordtype}{void} for\_each(\textcolor{keyword}{const} \mbox{\hyperlink{classhope_1_1flat__tuple}{flat\_tuple}}\& tuple2, F\&\& f)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{142                 (f(\mbox{\hyperlink{structhope_1_1detail_1_1get}{get<Is>}}(), tuple2.template \mbox{\hyperlink{structhope_1_1detail_1_1get}{get<Is>}}()), ...);}
\DoxyCodeLine{143             \}}
\DoxyCodeLine{144 }
\DoxyCodeLine{150             \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{151             \textcolor{keyword}{constexpr} \textcolor{keywordtype}{void} \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_01_4_00_01_ts_8_8_8_01_4_abb79287ce9b6dda01b61957ed41bf2c7}{for\_each}}(F\&\& f) \{}
\DoxyCodeLine{152                 (f(\mbox{\hyperlink{structhope_1_1detail_1_1get}{get<Is>}}()), ...);}
\DoxyCodeLine{153             \}}
\DoxyCodeLine{154 }
\DoxyCodeLine{155             \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{156             \textcolor{keyword}{constexpr} \textcolor{keywordtype}{void} for\_each(\mbox{\hyperlink{classhope_1_1flat__tuple}{flat\_tuple}}\& tuple2, F\&\& f) \{}
\DoxyCodeLine{157                 (f(\mbox{\hyperlink{structhope_1_1detail_1_1get}{get<Is>}}(), tuple2.template \mbox{\hyperlink{structhope_1_1detail_1_1get}{get<Is>}}()), ...);}
\DoxyCodeLine{158             \}}
\DoxyCodeLine{159 }
\DoxyCodeLine{164             [[nodiscard]] \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_01_4_00_01_ts_8_8_8_01_4_aa974184168a47b1aec781dcc4ffbd4fc}{get\_size}}() noexcept \{}
\DoxyCodeLine{165                 \textcolor{keywordflow}{return} tuple\_size;}
\DoxyCodeLine{166             \}}
\DoxyCodeLine{167         \textcolor{keyword}{private}:}
\DoxyCodeLine{168 }
\DoxyCodeLine{175             \textcolor{keyword}{template}<std::\textcolor{keywordtype}{size\_t} N, \textcolor{keyword}{typename} NativeT>}
\DoxyCodeLine{176             [[nodiscard]] \textcolor{keyword}{constexpr} \textcolor{keyword}{decltype}(\textcolor{keyword}{auto})}
\DoxyCodeLine{177             get\_impl() const noexcept \{}
\DoxyCodeLine{178                 \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }NativeT\&\textcolor{keyword}{>}(}
\DoxyCodeLine{179                     \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }\mbox{\hyperlink{structhope_1_1detail_1_1indexed__value}{indexed\_value < NativeT, N >}}\&\textcolor{keyword}{>} (*this).value}
\DoxyCodeLine{180                     );}
\DoxyCodeLine{181             \}}
\DoxyCodeLine{182 }
\DoxyCodeLine{189             \textcolor{keyword}{template}<std::\textcolor{keywordtype}{size\_t} N, \textcolor{keyword}{typename} NativeT>}
\DoxyCodeLine{190             \textcolor{keyword}{constexpr} \textcolor{keyword}{decltype}(\textcolor{keyword}{auto})}
\DoxyCodeLine{191             get\_impl() noexcept \{}
\DoxyCodeLine{192                 \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}NativeT\&\textcolor{keyword}{>}(}
\DoxyCodeLine{193                     \textcolor{keyword}{static\_cast<}indexed\_value < NativeT, N >\&\textcolor{keyword}{>} (*this).value}
\DoxyCodeLine{194                     );}
\DoxyCodeLine{195             \}}
\DoxyCodeLine{196 }
\DoxyCodeLine{203             \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} I>}
\DoxyCodeLine{204             [[nodiscard]] \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} deduce\_type() const noexcept \{}
\DoxyCodeLine{205                 \textcolor{comment}{// we cannot unambiguous determine holding type, thus try to cast to value and ref, and const ref...}}
\DoxyCodeLine{206                 \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_base\_of\_v<indexed\_value<T, I>, self\_t>)}
\DoxyCodeLine{207                     \textcolor{keywordflow}{return} type\_holder<T>\{\};}
\DoxyCodeLine{208                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_base\_of\_v<indexed\_value<T\&, I>, self\_t>)}
\DoxyCodeLine{209                     \textcolor{keywordflow}{return} type\_holder<T\&>\{\};}
\DoxyCodeLine{210                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{211                     \textcolor{keywordflow}{return} type\_holder<const T\&>\{\};}
\DoxyCodeLine{212             \}}
\DoxyCodeLine{213         \};}
\DoxyCodeLine{214 }
\DoxyCodeLine{215         \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{216         \textcolor{keyword}{using} flat\_tuple\_t = flat\_tuple\_impl < std::make\_index\_sequence < size(type\_list<Ts...>\{\}) > , Ts... > ;}
\DoxyCodeLine{217     \}}
\DoxyCodeLine{218 }
\DoxyCodeLine{224     \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{225     \textcolor{keyword}{class }\mbox{\hyperlink{classhope_1_1flat__tuple}{flat\_tuple}} final : \textcolor{keyword}{public} \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl}{detail::flat\_tuple\_t}}<Ts...> \{}
\DoxyCodeLine{226     \textcolor{keyword}{public}:}
\DoxyCodeLine{227         \textcolor{keyword}{template} <\textcolor{keyword}{typename}... VTs,}
\DoxyCodeLine{228             \textcolor{keyword}{typename} = std::enable\_if\_t<std::is\_same\_v<type\_list<std::decay\_t<VTs>...>, \mbox{\hyperlink{classhope_1_1type__list}{type\_list<std::decay\_t<Ts>}}...>>>>}
\DoxyCodeLine{229             \textcolor{keyword}{constexpr} \mbox{\hyperlink{classhope_1_1flat__tuple}{flat\_tuple}}(VTs\&\&... elems) noexcept}
\DoxyCodeLine{230             : \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl}{detail::flat\_tuple\_t}}<Ts...>(std::forward<VTs>(elems)...)}
\DoxyCodeLine{231         \{ \}}
\DoxyCodeLine{232         \textcolor{keyword}{constexpr} \mbox{\hyperlink{classhope_1_1flat__tuple}{flat\_tuple}}()}
\DoxyCodeLine{233             : \mbox{\hyperlink{classhope_1_1detail_1_1flat__tuple__impl}{detail::flat\_tuple\_t}}<Ts...>()}
\DoxyCodeLine{234         \{ \}}
\DoxyCodeLine{235     \};}
\DoxyCodeLine{236 }
\DoxyCodeLine{237     \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{238     \mbox{\hyperlink{classhope_1_1flat__tuple}{flat\_tuple}}(Ts...)-\/>flat\_tuple<Ts...>;}
\DoxyCodeLine{239 }
\DoxyCodeLine{247     \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{248     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} make\_flat\_tuple(Ts\&\&... args) \{}
\DoxyCodeLine{249         \textcolor{keywordflow}{return} \mbox{\hyperlink{classhope_1_1flat__tuple}{flat\_tuple<std::decay\_t<Ts>}}...>(std::forward<Ts>(args)...);}
\DoxyCodeLine{250     \}}
\DoxyCodeLine{251 }
\DoxyCodeLine{258     \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{259     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} make\_flat\_tuple\_bitfield\_friendly(Ts... args) \{}
\DoxyCodeLine{260         \textcolor{keywordflow}{return} flat\_tuple<std::decay\_t<Ts>...>(std::forward<Ts>(args)...);}
\DoxyCodeLine{261     \}}
\DoxyCodeLine{262 }
\DoxyCodeLine{269     \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{270     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} make\_flat\_ref\_tuple(Ts\&\&... args) \{}
\DoxyCodeLine{271         \textcolor{keywordflow}{return} flat\_tuple<Ts...>(std::forward<Ts>(args)...);}
\DoxyCodeLine{272     \}}
\DoxyCodeLine{273 }
\DoxyCodeLine{274     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Tuple, \textcolor{keyword}{typename} F>}
\DoxyCodeLine{275     \textcolor{keyword}{constexpr} std::enable\_if\_t<std::is\_base\_of\_v<detail::tuple\_tag, std::decay\_t<Tuple>>>}
\DoxyCodeLine{276     for\_each(Tuple\&\& tuple, F\&\& f) \{}
\DoxyCodeLine{277         tuple.for\_each(std::forward<F>(f));}
\DoxyCodeLine{278     \}}
\DoxyCodeLine{279 }
\DoxyCodeLine{280     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Tuple, \textcolor{keyword}{typename} F>}
\DoxyCodeLine{281     \textcolor{keyword}{constexpr} std::enable\_if\_t<std::is\_base\_of\_v<detail::tuple\_tag, std::decay\_t<Tuple>>>}
\DoxyCodeLine{282     for\_each(Tuple\&\& tuple1, Tuple\&\& tuple2, F\&\& f) \{}
\DoxyCodeLine{283         tuple1.for\_each(std::forward<Tuple>(tuple2), std::forward<F>(f));}
\DoxyCodeLine{284     \}}
\DoxyCodeLine{285 \}}

\end{DoxyCode}
