<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hope: hope::memory::chunk Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hope<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>hope</b></li><li class="navelem"><b>memory</b></li><li class="navelem"><a class="el" href="structhope_1_1memory_1_1chunk.html">chunk</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structhope_1_1memory_1_1chunk-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">hope::memory::chunk Struct Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Low level chunk allocator, is made such as tricky linked list first byte of the chunks block stores position of the next available element, thus we try to avoid extra memory utilization, also chunk knows nothing about it's block size, therefore alloc and dealloc methods looks so strange (their signature contain related params...) but it is worth remembering that chunk can't allocate blocks with different sizes.  
 <a href="structhope_1_1memory_1_1chunk.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="chunk_8h_source.html">chunk.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf928e403f88bb938e90dbf2d689b6ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhope_1_1memory_1_1chunk.html#acf928e403f88bb938e90dbf2d689b6ed">init</a> (std::size_t block_size, uint8_t blocks_count) noexcept</td></tr>
<tr class="memdesc:acf928e403f88bb938e90dbf2d689b6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">I decide to do not use RAII principle, to avoid any explicit constructors chunk should be as simple struct as possible, btw it is lowest level in allocation hierarchy.  <a href="structhope_1_1memory_1_1chunk.html#acf928e403f88bb938e90dbf2d689b6ed">More...</a><br /></td></tr>
<tr class="separator:acf928e403f88bb938e90dbf2d689b6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206a4519e9dff7d8d54f8650446f350d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhope_1_1memory_1_1chunk.html#a206a4519e9dff7d8d54f8650446f350d">allocate</a> (std::size_t block_size) noexcept</td></tr>
<tr class="memdesc:a206a4519e9dff7d8d54f8650446f350d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocation of chunks block, block_size is passed throw methods parameter, because it is too expensive to store this value at the chunk struct (due to the allocators hierarchy, see <a class="el" href="fixed__allocator_8h_source.html">fixed_allocator.h</a> for more details) this method extract first available block from linked list, and do other related work, it is easy to understand.  <a href="structhope_1_1memory_1_1chunk.html#a206a4519e9dff7d8d54f8650446f350d">More...</a><br /></td></tr>
<tr class="separator:a206a4519e9dff7d8d54f8650446f350d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67127097fa2f304eb663b867b63007e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhope_1_1memory_1_1chunk.html#a67127097fa2f304eb663b867b63007e6">deallocate</a> (void *ptr, std::size_t block_size) noexcept</td></tr>
<tr class="memdesc:a67127097fa2f304eb663b867b63007e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">freed passed memory witch is related by the passed pointer  <a href="structhope_1_1memory_1_1chunk.html#a67127097fa2f304eb663b867b63007e6">More...</a><br /></td></tr>
<tr class="separator:a67127097fa2f304eb663b867b63007e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128474f2b0f4ae41f2d3e46f607f63b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhope_1_1memory_1_1chunk.html#a128474f2b0f4ae41f2d3e46f607f63b7">is_deallocation_valid</a> (void *ptr, std::size_t block_size) const noexcept</td></tr>
<tr class="memdesc:a128474f2b0f4ae41f2d3e46f607f63b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if deallocation of passed ptr with passed value is available, otherwise we just cough memory corruption ot other invalid activity  <a href="structhope_1_1memory_1_1chunk.html#a128474f2b0f4ae41f2d3e46f607f63b7">More...</a><br /></td></tr>
<tr class="separator:a128474f2b0f4ae41f2d3e46f607f63b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee824910780f0562c431cecabb958781"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhope_1_1memory_1_1chunk.html#aee824910780f0562c431cecabb958781">is_allocation_valid</a> (std::size_t block_size) const noexcept</td></tr>
<tr class="memdesc:aee824910780f0562c431cecabb958781"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if allocation of block currently available  <a href="structhope_1_1memory_1_1chunk.html#aee824910780f0562c431cecabb958781">More...</a><br /></td></tr>
<tr class="separator:aee824910780f0562c431cecabb958781"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab24f7c3e19c4f0d4eab43e89eaf68708"><td class="memItemLeft" align="right" valign="top"><a id="ab24f7c3e19c4f0d4eab43e89eaf68708" name="ab24f7c3e19c4f0d4eab43e89eaf68708"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> { nullptr }</td></tr>
<tr class="separator:ab24f7c3e19c4f0d4eab43e89eaf68708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d704ff31dd3714a812c9d012d70fb6"><td class="memItemLeft" align="right" valign="top"><a id="a29d704ff31dd3714a812c9d012d70fb6" name="a29d704ff31dd3714a812c9d012d70fb6"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>free_blocks_count</b> { 0 }</td></tr>
<tr class="separator:a29d704ff31dd3714a812c9d012d70fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c06e17d26cf8377da79091e274722c6"><td class="memItemLeft" align="right" valign="top"><a id="a0c06e17d26cf8377da79091e274722c6" name="a0c06e17d26cf8377da79091e274722c6"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>first_free_block</b> { 0 }</td></tr>
<tr class="separator:a0c06e17d26cf8377da79091e274722c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Low level chunk allocator, is made such as tricky linked list first byte of the chunks block stores position of the next available element, thus we try to avoid extra memory utilization, also chunk knows nothing about it's block size, therefore alloc and dealloc methods looks so strange (their signature contain related params...) but it is worth remembering that chunk can't allocate blocks with different sizes. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a206a4519e9dff7d8d54f8650446f350d" name="a206a4519e9dff7d8d54f8650446f350d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206a4519e9dff7d8d54f8650446f350d">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * hope::memory::chunk::allocate </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocation of chunks block, block_size is passed throw methods parameter, because it is too expensive to store this value at the chunk struct (due to the allocators hierarchy, see <a class="el" href="fixed__allocator_8h_source.html">fixed_allocator.h</a> for more details) this method extract first available block from linked list, and do other related work, it is easy to understand. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_size</td><td>- size of block to be allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the desired memory segment </dd></dl>

</div>
</div>
<a id="a67127097fa2f304eb663b867b63007e6" name="a67127097fa2f304eb663b867b63007e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67127097fa2f304eb663b867b63007e6">&#9670;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hope::memory::chunk::deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>freed passed memory witch is related by the passed pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to the memory block to be allocated, value should be in range of [data, data + block_size * blocks_count] in other words this memory should be recently allocated from this chunk </td></tr>
    <tr><td class="paramname">block_size</td><td>size of block to be freed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf928e403f88bb938e90dbf2d689b6ed" name="acf928e403f88bb938e90dbf2d689b6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf928e403f88bb938e90dbf2d689b6ed">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hope::memory::chunk::init </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blocks_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>I decide to do not use RAII principle, to avoid any explicit constructors chunk should be as simple struct as possible, btw it is lowest level in allocation hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_size</td><td>size of single block to be stored at the chunk; this is only one lock size which is available for allocation </td></tr>
    <tr><td class="paramname">blocks_count</td><td>count of chunk's blocks to be allocated, value in range of [0, 255] this is most appropriate interval to avoid memory alignment falls (maximum available index of chunk block is 255 due to byte size) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee824910780f0562c431cecabb958781" name="aee824910780f0562c431cecabb958781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee824910780f0562c431cecabb958781">&#9670;&nbsp;</a></span>is_allocation_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hope::memory::chunk::is_allocation_valid </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if allocation of block currently available </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_size</td><td>size of block to be allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if allocation is possible </dd></dl>

</div>
</div>
<a id="a128474f2b0f4ae41f2d3e46f607f63b7" name="a128474f2b0f4ae41f2d3e46f607f63b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128474f2b0f4ae41f2d3e46f607f63b7">&#9670;&nbsp;</a></span>is_deallocation_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hope::memory::chunk::is_deallocation_valid </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks if deallocation of passed ptr with passed value is available, otherwise we just cough memory corruption ot other invalid activity </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to the block to be deallocated </td></tr>
    <tr><td class="paramname">block_size</td><td>size of deallocating block <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true id deallocation may be successful, otherwise false </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lib/hope/memory/small_object/<a class="el" href="chunk_8h_source.html">chunk.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
