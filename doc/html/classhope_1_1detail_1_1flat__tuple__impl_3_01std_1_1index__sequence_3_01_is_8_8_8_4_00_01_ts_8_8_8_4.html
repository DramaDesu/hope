<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>hope: hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>hope</b>::<b>detail</b>::<a class="el" href="classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_4_00_01_ts_8_8_8_4.html">flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;</a>
  </div>
</div>
<div class="contents">
<h1>hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt; Class Template Reference</h1><!-- doxytag: class="hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;" --><!-- doxytag: inherits="hope::detail::tuple_tag,indexed_value&lt; Ts, Is &gt;" --><code>#include &lt;<a class="el" href="flat__tuple_8h-source.html">flat_tuple.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;:</div>
<div class="dynsection">

<p><center><img src="classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_4_00_01_ts_8_8_8_4.png" usemap="#hope::detail::flat_tuple_impl< std::index_sequence< Is...>, Ts...>_map" border="0" alt=""></center>
<map name="hope::detail::flat_tuple_impl< std::index_sequence< Is...>, Ts...>_map">
<area href="structhope_1_1detail_1_1tuple__tag.html" alt="hope::detail::tuple_tag" shape="rect" coords="0,0,368,24">
<area href="structhope_1_1detail_1_1indexed__value.html" alt="hope::detail::indexed_value< Ts, Is >" shape="rect" coords="378,0,746,24">
</map>
</div>

<p>
<a href="classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_4_00_01_ts_8_8_8_4-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , typename NativeT  = std::decay_t&lt;T&gt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">constexpr&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_4_00_01_ts_8_8_8_4.html#6f82e0562ca06b099334fa7c08e0eb64">decltype</a> (auto) get() noexcept</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to find element of specified type, fails on static assert if element had not been found; method is not sensitive to the qualifiers, followed constructions are equal: get&lt;int&gt;() get&lt;int&amp;&gt;() , get&lt;const int&gt;(), get&lt;const int&amp;&gt;(); accessed value will be automatically deduced by tuple's type (regardless of field policy is being used to create the tuple).  <a href="#6f82e0562ca06b099334fa7c08e0eb64"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , typename NativeT  = std::decay_t&lt;T&gt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">constexpr&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_4_00_01_ts_8_8_8_4.html#0db8adfa32e775efc297ffd41fdda6a7">decltype</a> (auto) get() const noexcept</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to find element of specified type, fails on static assert if element had not been found; method is not sensitive to the qualifiers, followed constructions are equal: get&lt;int&gt;() get&lt;int&amp;&gt;() , get&lt;const int&gt;(), get&lt;const int&amp;&gt;(); accessed value will be automatically deduced by tuple's type (regardless of field policy is being used to create the tuple).  <a href="#0db8adfa32e775efc297ffd41fdda6a7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">constexpr&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_4_00_01_ts_8_8_8_4.html#6f82e0562ca06b099334fa7c08e0eb64">decltype</a> (auto) get() noexcept</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to find element with given index.  <a href="#6f82e0562ca06b099334fa7c08e0eb64"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">constexpr&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_4_00_01_ts_8_8_8_4.html#0db8adfa32e775efc297ffd41fdda6a7">decltype</a> (auto) get() const noexcept</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to find element with given index.  <a href="#0db8adfa32e775efc297ffd41fdda6a7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">constexpr void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_4_00_01_ts_8_8_8_4.html#666a36927404ca2f5d9faeeb9da9c039">for_each</a> (F &amp;&amp;f) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies given functor to each value of tuple, more useful analogue of std::apply.  <a href="#666a36927404ca2f5d9faeeb9da9c039"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">constexpr void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_4_00_01_ts_8_8_8_4.html#217b9226418ab5ac765404e6632a8083">for_each</a> (const flat_tuple &amp;tuple2, F &amp;&amp;f) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies given functor to each value of tuples.  <a href="#217b9226418ab5ac765404e6632a8083"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">constexpr void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_4_00_01_ts_8_8_8_4.html#1ef2389962afceff73d54483975f5628">for_each</a> (F &amp;&amp;f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies given functor to each value of given tuple, more useful analogue of std::apply.  <a href="#1ef2389962afceff73d54483975f5628"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">constexpr void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_4_00_01_ts_8_8_8_4.html#90c90aefa83c884fc686a98175d8fcd6">for_each</a> (flat_tuple &amp;tuple2, F &amp;&amp;f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies given functor to each value of tuples.  <a href="#90c90aefa83c884fc686a98175d8fcd6"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static constexpr auto&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhope_1_1detail_1_1flat__tuple__impl_3_01std_1_1index__sequence_3_01_is_8_8_8_4_00_01_ts_8_8_8_4.html#e8c18d2b32dc3aee7818265152bbfa46">get_size</a> () noexcept</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">just returns the size of the tuple (means number of fields)  <a href="#e8c18d2b32dc3aee7818265152bbfa46"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2c05f9d62b48ab44dbc4493305e58e4e"></a><!-- doxytag: member="hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::flat_tuple_impl" ref="2c05f9d62b48ab44dbc4493305e58e4e" args="(const flat_tuple_impl &amp;)" -->
constexpr&nbsp;</td><td class="memItemRight" valign="bottom"><b>flat_tuple_impl</b> (const flat_tuple_impl &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="095208e9f5ec49ad23353721d69f0868"></a><!-- doxytag: member="hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::flat_tuple_impl" ref="095208e9f5ec49ad23353721d69f0868" args="(flat_tuple_impl &amp;&amp;)" -->
constexpr&nbsp;</td><td class="memItemRight" valign="bottom"><b>flat_tuple_impl</b> (flat_tuple_impl &amp;&amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="583a3a3d9e0227fc5aaf11133d8bd5be"></a><!-- doxytag: member="hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::flat_tuple_impl" ref="583a3a3d9e0227fc5aaf11133d8bd5be" args="(VTs &amp;&amp;...elems) noexcept" -->
template&lt;typename... VTs&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">constexpr&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>flat_tuple_impl</b> (VTs &amp;&amp;...elems) noexcept</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;std::size_t... Is, typename... Ts&gt;<br>
 class hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;</h3>

General class of the all static reflection module. <dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Is</em>&nbsp;</td><td>Helper sequence of indexes, max(Is...) + is the count of the tuple's elements </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Ts</em>&nbsp;</td><td>Types stored in the tuple </td></tr>
  </table>
</dl>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="0db8adfa32e775efc297ffd41fdda6a7"></a><!-- doxytag: member="hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::decltype" ref="0db8adfa32e775efc297ffd41fdda6a7" args="(auto) get() const noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... Is, typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::decltype           </td>
          <td>(</td>
          <td class="paramtype">auto&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to find element with given index. 
<p>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>Index of the element to be found </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Reference to the containing element, const and ref qualifiers of the containing one do not change, ref will be returned "as is" </dd></dl>

</div>
</div><p>
<a class="anchor" name="6f82e0562ca06b099334fa7c08e0eb64"></a><!-- doxytag: member="hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::decltype" ref="6f82e0562ca06b099334fa7c08e0eb64" args="(auto) get() noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... Is, typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::decltype           </td>
          <td>(</td>
          <td class="paramtype">auto&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to find element with given index. 
<p>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>Index of the element to be found </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Reference to the containing element, const and ref qualifiers of the containing one are not change, ref will be returned "as is" </dd></dl>

</div>
</div><p>
<a class="anchor" name="0db8adfa32e775efc297ffd41fdda6a7"></a><!-- doxytag: member="hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::decltype" ref="0db8adfa32e775efc297ffd41fdda6a7" args="(auto) get() const noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... Is, typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename NativeT  = std::decay_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::decltype           </td>
          <td>(</td>
          <td class="paramtype">auto&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to find element of specified type, fails on static assert if element had not been found; method is not sensitive to the qualifiers, followed constructions are equal: get&lt;int&gt;() get&lt;int&amp;&gt;() , get&lt;const int&gt;(), get&lt;const int&amp;&gt;(); accessed value will be automatically deduced by tuple's type (regardless of field policy is being used to create the tuple). 
<p>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>: Type of element to be returned, const and reference qualifiers does not matter</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NativeT</em>&nbsp;</td><td>: clear type, used to deduce return type and check whether tuple has element with specified value or not</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>reference to the containing element </dd></dl>

</div>
</div><p>
<a class="anchor" name="6f82e0562ca06b099334fa7c08e0eb64"></a><!-- doxytag: member="hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::decltype" ref="6f82e0562ca06b099334fa7c08e0eb64" args="(auto) get() noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... Is, typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename NativeT  = std::decay_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::decltype           </td>
          <td>(</td>
          <td class="paramtype">auto&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to find element of specified type, fails on static assert if element had not been found; method is not sensitive to the qualifiers, followed constructions are equal: get&lt;int&gt;() get&lt;int&amp;&gt;() , get&lt;const int&gt;(), get&lt;const int&amp;&gt;(); accessed value will be automatically deduced by tuple's type (regardless of field policy is being used to create the tuple). 
<p>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>: Type of element to be returned, const and reference qualifiers does not matter</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NativeT</em>&nbsp;</td><td>: clear type, used to deduce return type and check whether tuple has element with specified value or not</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>reference to the containing element </dd></dl>

</div>
</div><p>
<a class="anchor" name="90c90aefa83c884fc686a98175d8fcd6"></a><!-- doxytag: member="hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::for_each" ref="90c90aefa83c884fc686a98175d8fcd6" args="(flat_tuple &amp;tuple2, F &amp;&amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... Is, typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr void hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::for_each           </td>
          <td>(</td>
          <td class="paramtype">flat_tuple &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies given functor to each value of tuples. 
<p>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>F</em>&nbsp;</td><td>type of functional object </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tuple2</em>&nbsp;</td><td>second tuple the function to be applied to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>functional object to be sequentially applied to each field of tuple </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1ef2389962afceff73d54483975f5628"></a><!-- doxytag: member="hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::for_each" ref="1ef2389962afceff73d54483975f5628" args="(F &amp;&amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... Is, typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr void hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::for_each           </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies given functor to each value of given tuple, more useful analogue of std::apply. 
<p>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>F</em>&nbsp;</td><td>type of functional object </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>functional object to be sequentially applied to each field of tuple </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="217b9226418ab5ac765404e6632a8083"></a><!-- doxytag: member="hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::for_each" ref="217b9226418ab5ac765404e6632a8083" args="(const flat_tuple &amp;tuple2, F &amp;&amp;f) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... Is, typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr void hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::for_each           </td>
          <td>(</td>
          <td class="paramtype">const flat_tuple &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies given functor to each value of tuples. 
<p>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>F</em>&nbsp;</td><td>type of functional object </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tuple2</em>&nbsp;</td><td>second tuple the function to be applied to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>functional object to be sequentially applied to each field of tuple </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="666a36927404ca2f5d9faeeb9da9c039"></a><!-- doxytag: member="hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::for_each" ref="666a36927404ca2f5d9faeeb9da9c039" args="(F &amp;&amp;f) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... Is, typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr void hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::for_each           </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies given functor to each value of tuple, more useful analogue of std::apply. 
<p>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>F</em>&nbsp;</td><td>type of functional object </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>functional object to be sequentially applied to each field of tuple </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e8c18d2b32dc3aee7818265152bbfa46"></a><!-- doxytag: member="hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::get_size" ref="e8c18d2b32dc3aee7818265152bbfa46" args="() noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... Is, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto hope::detail::flat_tuple_impl&lt; std::index_sequence&lt; Is...&gt;, Ts...&gt;::get_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
just returns the size of the tuple (means number of fields) 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of fields </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>lib/hope/tuple/<a class="el" href="flat__tuple_8h-source.html">flat_tuple.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Sep 25 22:14:02 2021 for hope by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
