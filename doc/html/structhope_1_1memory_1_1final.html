<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>hope: hope::memory::final Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>hope</b>::<b>memory</b>::<a class="el" href="structhope_1_1memory_1_1final.html">final</a>
  </div>
</div>
<div class="contents">
<h1>hope::memory::final Class Reference</h1><!-- doxytag: class="hope::memory::final" -->Low level chunk allocator, is made such as tricky linked list first byte of the chunks block stores position of the next available element, thus we try to avoid extra memory utilization, also chunk knows nothing about it's block size, therefore alloc and dealloc methods looks so strange (their signature contain related params...) but it is worth remembering that chunk can't allocate blocks with different sizes.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="chunk_8h-source.html">chunk.h</a>&gt;</code>
<p>

<p>
<a href="classhope_1_1memory_1_1final-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhope_1_1memory_1_1final.html#4ceb422bbc652ee386c8458abc959425">init</a> (std::size_t block_size, uint8_t blocks_count) noexcept</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">I decide to do not use RAII principle, to avoid any explicit constructors chunk should be as simple struct as possible, btw it is lowest level in allocation hierarchy.  <a href="#4ceb422bbc652ee386c8458abc959425"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhope_1_1memory_1_1final.html#6b0b52dcc62d04aa1a8c3bb6168a7ce4">allocate</a> (std::size_t block_size) noexcept</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocation of chunks block, block_size is passed throw methods parameter, because it is too expensive to store this value at the chunk struct (due to the allocators hierarchy, see <a class="el" href="fixed__allocator_8h-source.html">fixed_allocator.h</a> for more details) this method extract first available block from linked list, and do other related work, it is easy to understand.  <a href="#6b0b52dcc62d04aa1a8c3bb6168a7ce4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhope_1_1memory_1_1final.html#9c7e918080a8c1429ec8d241e7dfe0cf">deallocate</a> (void *ptr, std::size_t block_size) noexcept</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">freed passed memory witch is related by the passed pointer  <a href="#9c7e918080a8c1429ec8d241e7dfe0cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhope_1_1memory_1_1final.html#180904dab84e90547c6664815c449416">is_deallocation_valid</a> (void *ptr, std::size_t block_size) const noexcept</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">checks if deallocation of passed ptr with passed value is available, otherwise we just cough memory corruption ot other invalid activity  <a href="#180904dab84e90547c6664815c449416"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhope_1_1memory_1_1final.html#44c5aa574f7dea1a3689fdb6e1215bf1">is_allocation_valid</a> (std::size_t block_size) const noexcept</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">check if allocation of block currently available  <a href="#44c5aa574f7dea1a3689fdb6e1215bf1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ca1fedc5f4cb9a16cd668f09cf0c5233"></a><!-- doxytag: member="hope::memory::final::fixed_allocator" ref="ca1fedc5f4cb9a16cd668f09cf0c5233" args="(uint8_t max_blocks_count, std::size_t block_size) noexcept" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>fixed_allocator</b> (uint8_t max_blocks_count, std::size_t block_size) noexcept</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bc3b393955cb128645dddaaa2e3a7cce"></a><!-- doxytag: member="hope::memory::final::fixed_allocator" ref="bc3b393955cb128645dddaaa2e3a7cce" args="(fixed_allocator &amp;&amp;rhs) noexcept" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>fixed_allocator</b> (fixed_allocator &amp;&amp;rhs) noexcept</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b36950f24b55764a6a628803d53163c3"></a><!-- doxytag: member="hope::memory::final::operator=" ref="b36950f24b55764a6a628803d53163c3" args="(fixed_allocator &amp;&amp;rhs) noexcept" -->
fixed_allocator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (fixed_allocator &amp;&amp;rhs) noexcept</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhope_1_1memory_1_1final.html#3e02f1cf966f5447a579d51afa98330c">fixed_allocator</a> (const fixed_allocator &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">to avoid extra or unsafe copying we have to explicitly delete copy constructor and copy assign operator also, we should create explicit noexcept move constructor and copy assign operator  <a href="#3e02f1cf966f5447a579d51afa98330c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ce713dd85f29313a87f24eae31a5a809"></a><!-- doxytag: member="hope::memory::final::operator=" ref="ce713dd85f29313a87f24eae31a5a809" args="(const fixed_allocator &amp;rhs)" -->
fixed_allocator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const fixed_allocator &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="517c29298f9b737bce38f335df100461"></a><!-- doxytag: member="hope::memory::final::allocate" ref="517c29298f9b737bce38f335df100461" args="() noexcept" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhope_1_1memory_1_1final.html#517c29298f9b737bce38f335df100461">allocate</a> () noexcept</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">allocate block with m_block_size size <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="da58e8008844f554080b7ebd9513035d"></a><!-- doxytag: member="hope::memory::final::deallocate" ref="da58e8008844f554080b7ebd9513035d" args="(void *ptr) noexcept" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhope_1_1memory_1_1final.html#da58e8008844f554080b7ebd9513035d">deallocate</a> (void *ptr) noexcept</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to deallocate passed pointer, if it were allocated by another memory pool in debug this caused assert failure in realize mode this causes undefined behavior <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6bf303e9162923afc80ef1b3081a1fa"></a><!-- doxytag: member="hope::memory::final::block_size" ref="f6bf303e9162923afc80ef1b3081a1fa" args="() const noexcept" -->
std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhope_1_1memory_1_1final.html#f6bf303e9162923afc80ef1b3081a1fa">block_size</a> () const noexcept</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns size of block, witch may be allocated <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="574fe43c8a88fab43e213dd568f1db78"></a><!-- doxytag: member="hope::memory::final::small_object_allocator" ref="574fe43c8a88fab43e213dd568f1db78" args="(const small_object_allocator &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>small_object_allocator</b> (const small_object_allocator &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4e4c83e609c448a110754eb8b68c3096"></a><!-- doxytag: member="hope::memory::final::small_object_allocator" ref="4e4c83e609c448a110754eb8b68c3096" args="(small_object_allocator &amp;&amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>small_object_allocator</b> (small_object_allocator &amp;&amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6c1420340012d0490acff1905652b81c"></a><!-- doxytag: member="hope::memory::final::operator=" ref="6c1420340012d0490acff1905652b81c" args="(const small_object_allocator &amp;)" -->
small_object_allocator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const small_object_allocator &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bfd98ecd6fb623123d8bf2870e696953"></a><!-- doxytag: member="hope::memory::final::operator=" ref="bfd98ecd6fb623123d8bf2870e696953" args="(small_object_allocator &amp;&amp;)" -->
small_object_allocator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (small_object_allocator &amp;&amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c4a6466c5b4eca5c9251eb4406540cb6"></a><!-- doxytag: member="hope::memory::final::deallocate" ref="c4a6466c5b4eca5c9251eb4406540cb6" args="(void *ptr, std::size_t size) noexcept" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhope_1_1memory_1_1final.html#c4a6466c5b4eca5c9251eb4406540cb6">deallocate</a> (void *ptr, std::size_t size) noexcept</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to deallocate passed pointer to object since allocator is stateful, you cannot deallocate objects, which were allocated by this class params meaning are trivial <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ddd2a53238c4a13ac22734a0ff70e594"></a><!-- doxytag: member="hope::memory::final::allocate" ref="ddd2a53238c4a13ac22734a0ff70e594" args="(std::size_t size) noexcept" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhope_1_1memory_1_1final.html#ddd2a53238c4a13ac22734a0ff70e594">allocate</a> (std::size_t size) noexcept</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to allocate object, if passed size greater than m_max_object_size, operator new will be called params meaning are trivial <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="60ac0028ba156818940a7c7da2ba12e1"></a><!-- doxytag: member="hope::memory::final::instance" ref="60ac0028ba156818940a7c7da2ba12e1" args="()" -->
static small_object_allocator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhope_1_1memory_1_1final.html#60ac0028ba156818940a7c7da2ba12e1">instance</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">just return instance of singleton NOTE: before use this class, u have to initialize its instance, see small_object_allocator::initialize <br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="430993a05a9a34af3e25581753c4d24a"></a><!-- doxytag: member="hope::memory::final::sm_allocator_reset" ref="430993a05a9a34af3e25581753c4d24a" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>sm_allocator_reset</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Low level chunk allocator, is made such as tricky linked list first byte of the chunks block stores position of the next available element, thus we try to avoid extra memory utilization, also chunk knows nothing about it's block size, therefore alloc and dealloc methods looks so strange (their signature contain related params...) but it is worth remembering that chunk can't allocate blocks with different sizes. 
<p>
singleton, is used to hold list with fixed allocators of proper sizes <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="6b0b52dcc62d04aa1a8c3bb6168a7ce4"></a><!-- doxytag: member="hope::memory::final::allocate" ref="6b0b52dcc62d04aa1a8c3bb6168a7ce4" args="(std::size_t block_size) noexcept" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* hope::memory::final::allocate           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>block_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocation of chunks block, block_size is passed throw methods parameter, because it is too expensive to store this value at the chunk struct (due to the allocators hierarchy, see <a class="el" href="fixed__allocator_8h-source.html">fixed_allocator.h</a> for more details) this method extract first available block from linked list, and do other related work, it is easy to understand. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block_size</em>&nbsp;</td><td>- size of block to be allocated </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the desired memory segment </dd></dl>

</div>
</div><p>
<a class="anchor" name="9c7e918080a8c1429ec8d241e7dfe0cf"></a><!-- doxytag: member="hope::memory::final::deallocate" ref="9c7e918080a8c1429ec8d241e7dfe0cf" args="(void *ptr, std::size_t block_size) noexcept" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hope::memory::final::deallocate           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>block_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
freed passed memory witch is related by the passed pointer 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to the memory block to be allocated, value should be in range of [data, data + block_size * blocks_count] in other words this memory should be recently allocated from this chunk </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block_size</em>&nbsp;</td><td>size of block to be freed </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3e02f1cf966f5447a579d51afa98330c"></a><!-- doxytag: member="hope::memory::final::fixed_allocator" ref="3e02f1cf966f5447a579d51afa98330c" args="(const fixed_allocator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hope::memory::final::fixed_allocator           </td>
          <td>(</td>
          <td class="paramtype">const fixed_allocator &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
to avoid extra or unsafe copying we have to explicitly delete copy constructor and copy assign operator also, we should create explicit noexcept move constructor and copy assign operator 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4ceb422bbc652ee386c8458abc959425"></a><!-- doxytag: member="hope::memory::final::init" ref="4ceb422bbc652ee386c8458abc959425" args="(std::size_t block_size, uint8_t blocks_count) noexcept" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hope::memory::final::init           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>blocks_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
I decide to do not use RAII principle, to avoid any explicit constructors chunk should be as simple struct as possible, btw it is lowest level in allocation hierarchy. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block_size</em>&nbsp;</td><td>size of single block to be stored at the chunk; this is only one lock size which is available for allocation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blocks_count</em>&nbsp;</td><td>count of chunk's blocks to be allocated, value in range of [0, 255] this is most appropriate interval to avoid memory alignment falls (maximum available index of chunk block is 255 due to byte size) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="44c5aa574f7dea1a3689fdb6e1215bf1"></a><!-- doxytag: member="hope::memory::final::is_allocation_valid" ref="44c5aa574f7dea1a3689fdb6e1215bf1" args="(std::size_t block_size) const noexcept" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hope::memory::final::is_allocation_valid           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>block_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
check if allocation of block currently available 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block_size</em>&nbsp;</td><td>size of block to be allocated </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if allocation is possible </dd></dl>

</div>
</div><p>
<a class="anchor" name="180904dab84e90547c6664815c449416"></a><!-- doxytag: member="hope::memory::final::is_deallocation_valid" ref="180904dab84e90547c6664815c449416" args="(void *ptr, std::size_t block_size) const noexcept" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hope::memory::final::is_deallocation_valid           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>block_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
checks if deallocation of passed ptr with passed value is available, otherwise we just cough memory corruption ot other invalid activity 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to the block to be deallocated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block_size</em>&nbsp;</td><td>size of deallocating block </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true id deallocation may be successful, otherwise false </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>lib/hope/memory/small_object/<a class="el" href="chunk_8h-source.html">chunk.h</a><li>lib/hope/memory/small_object/<a class="el" href="fixed__allocator_8h-source.html">fixed_allocator.h</a><li>lib/hope/memory/small_object/<a class="el" href="small__object__allocator_8h-source.html">small_object_allocator.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Sep 25 22:14:02 2021 for hope by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
